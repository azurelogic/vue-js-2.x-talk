<!doctype html>
<!--suppress HtmlUnknownAttribute, XmlUnboundNsPrefix -->
<html xmlns:v-bind="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8">

  <title>Vue.js: Not just another SPA library</title>

  <meta name="description" content="A talk on getting started with Vue.js 2.x">
  <meta name="author" content="Rob Ribeiro">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/moon.css">
  <link rel="stylesheet" href="css/custom.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <script src="js/vue.js"></script>
  <script src="js/vuex.js"></script>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.17.1/moment.min.js"></script>
</head>
<body>
<div class="reveal">
  <div class="slides">
    <section data-markdown>
      <script type="text/template">
        # Vue.js
        ## Not just another SPA library

        Rob Ribeiro

        @azurelogic

        https://azurelogic.com
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## About me

        - DevOps Engineer @ Trek10
        - MS in Applied Math and CS from IUSB
        - This is my 6th talk for LV
        - I <3 JavaScript
        - Current obsession === Legend of Zelda: Breath of the Wild
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## SPA???

        <img src="spa.jpg" alt="Spa" style="height: 50vh"/>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Brief (and incomplete) history of SPA libraries

        - December 1995: VanillaJS ;)
        - March 2005: Dojo Toolkit
        - 2010: Knockout, Backbone, Angular 1
        - December 2011: Ember
        - March 2013: React
        - February 2014: Vue 1
        - September 2016: Angular 2, Vue 2
        - Others I'm too lazy to find: Mithril, Cycle, Preact, Inferno, Aurelia
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## [Vue.js](https://vuejs.org)

        - Created by Evan You
          - Xoogler, ex-meteorjs
        - 18 kb minified and gzipped
        - Angular 1 style templates
        - Virtual DOM like React
        - Flux pattern via Vuex
        - Neither prescriptive, nor monolithic
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Vue compared

        - Similar algorithms to React, but faster, lighter, and more automatic
          - No `shouldComponentUpdate` due to dependency tracking
        - Support both HTML templates and JSX
        - Use with or without ES2015+ or modern tooling like Webpack, ESLint, and other modern tooling
        - One way data flow avoids complexity
        - TypeScript friendly
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## [Library sizes minified and gzipped](https://gist.github.com/Restuta/cda69e50a853aa64912d)

        Name  | Size
        ------------- | -------------
        Ember 2.2.0     | 111K
        Angular 2       | 111K
        Angular 1.4.5   |    51K
        React 15.3.0 + React DOM | 43K
        Vue 2.0.3 | **23K** (18K without compiler)
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## [Benchmarks](http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html)

        Library | Mean slowdown | Library | Mean slowdown
        ------------- | ------------- | ------------- | -------------
        vanillajs | 1.00 | inferno | 1.07
        vue 2 | 1.37 | aurelia | 1.66
        vue 1 | 2.16 | mithril | 1.83
        angular 1.5 | 2.62 | react 15.3 | 1.82
        angular 2 | 1.85 | cyclejs 7 | 1.48
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Why you should give a crap

        - Faster than React
        - Easier than Angular
        - More compact then either of them
        - Gaining market and mind share rapidly
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Enough talk. Let's learn:
        # /^vue(?:x)?$/
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Associated libraries and tooling

        - [vuex](https://github.com/vuejs/vuex)
        - [vue-router](https://github.com/vuejs/vue-router)
        - [vue-cli](https://github.com/vuejs/vue-cli)
        - [Vue.js devtools for Chrome](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Bootstrapping

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="bootstrapApp"&gt;
          {{ message }}
        &lt;/div&gt;

        &lt;script src="/path/to/vue.js"&gt;

        &lt;script&gt;
        var bootstrapApp = new Vue({
          el: '#bootstrapApp',
          data: {
            message: 'Hello Vue!'
          }
        });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="bootstrapApp">
            {{ message }}
          </div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          bootstrapApp = new Vue({
            el: '#bootstrapApp',
            data: {
              message: 'Hello Vue!'
            }
          })
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Templates

        - Like Angular, Vue's primarily uses templates to perform declarative rendering of our data
        - Text: `<div>Hello {{ firstName + ' ' + lastName }}</div>`
          - Single expression only
          - Very limited global access (`Math`, `Date`, etc)
        - Raw HTML: `<div v-html="someHtml"></div>`
        - Attributes: `<a v-bind:href="url">Your profile</a>`
        - v-bind shorthand: `<a :href="url">Your profile</a>`
          - Retains data type!
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Templates

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="templateApp"&gt;
          &lt;a :href="url"&gt;{{ destination }}&lt;/a&gt;
        &lt;/div&gt;

        &lt;script&gt;
        var templateApp = new Vue({
          el: '#templateApp',
          data: {
            url: '//google.com',
            destination: 'Google'
          }
        });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="templateApp">
            <a :href="url">{{ destination }}</a>
          </div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          templateApp = new Vue({
            el: '#templateApp',
            data: {
              url: 'http://google.com',
              destination: 'Google'
            }
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Computed properties

        - Avoid jamming logic into your templates
        - Computed properties magically track their dependencies and reactively recompute
        - Can do computed properties with getters and setters

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="computedApp"&gt;&lt;/div&gt;

        &lt;script&gt;
        var computedApp = new Vue({
            el: '#computedApp',
            template: '<div><div>First: {{firstName}}</div>' +
            '<div>Last: {{lastName}}</div>' +
            '<div>Full: {{fullName}}</div></div>',
            data: {
              firstName: 'Rob',
              lastName: 'Ribeiro'
            },
            computed: {
              fullName() { return this.firstName + ' ' + this.lastName; }
            }
          });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="computedApp">
            <a :href="url">{{ destination }}</a>
          </div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          computedApp = new Vue({
            el: '#computedApp',
            template: '<div><div>First: {{firstName}}</div>' +
            '<div>Last: {{lastName}}</div>' +
            '<div>Full: {{fullName}}</div></div>',
            data: {
              firstName: 'Rob',
              lastName: 'Ribeiro'
            },
            computed: {
              fullName() { return this.firstName + ' ' + this.lastName; }
            }
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Components

        - Fundamental reusable Vue building block
        - Global registration: `Vue.component('tag-name', { /* component definition */ });`
          - Must register before creating root Vue instance (`new Vue(...)`)
        - Using components:
          - `<my-component></my-component>`
          - Dynamic rendering: `<div :is="componentType"></div>`

        <aside class="notes">
          - global registration makes the registered component available to all other components <br />
          - componentType for dynamic rendering can be string component name or actual component reference <br />
        </aside>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Single file components

        - The `.vue` file: a single file component definition containing template, JS, and CSS
        - The recommended way to write Vue, unless you have an advanced use case
        - Template must only have a single root element!
        - Requires build process, e.g.: Webpack with [vue-loader](https://github.com/vuejs/vue-loader)

        <div><pre><code>&lt;template&gt;
          &lt;div&gt;
            &lt;card-header :user="user"&gt;&lt;/card-header&gt;
            {{bodyText}}
          &lt;/div&gt;
        &lt;/template&gt;
        &lt;script&gt;
          import CardHeader from './CardHeader';
          export default {
            name: 'card',
            components: { CardHeader },
            data() { return { user: 'Alice', bodyText: 'Hello world!' }; }
          };
        &lt;/script&gt;
        &lt;style scoped&gt;...&lt;/style&gt;</code></pre></div>
        <aside class="notes">
          - Highlight local registration: tag name based on import name! <br />
          - Data as a function because each instance of a component needs separate data <br />
          - Name is used for debugging <br />
          - CSS only applies while component is part of current DOM
          - Scoped CSS option: when scoped, styles only apply within the component <br />
        </aside>
      </script>
    </section>
    <section data-markdown data-background-image="hammertime.gif">
      <script type="text/template">
        <div class="stop">
        <h1>STOP!!!</h1>
        <h2 class="fragment">How did bootstrapApp.message work???</h2>
        <h2 class="fragment">Shouldn't it be bootstrapApp.data().message?</h2>
        </div>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        # Nope.
        1. `data` is an object on the root Vue instance
        2. Even with components, things are not what you think they are...
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## How the reactive sausage is made

        - Root instance and components are defined with POJOs
        - Vue mangles all of your code with getter and setters for reactivity via change tracking
        - Your data, computed properties, props, and methods become part of the component instance
          - originals are preserved with `$` prefixes, e.g.: `app.$data`
        - Locally registered components and filters are available to the template as well
        - Problem 1: `this`, `=>`, and lexical binding
        - Problem 2: Adding new properties after the component is defined

        ```
        var app = new Vue({ data: { adults: 1, bar: {} } })
        // app.adults and app.bar are reactive
        app.children = 2 // app.b is NOT reactive and there's no way to make it reactive
        app.bar.whiskey = 2 // app.bar.whiskey is NOT reactive
        Vue.set(app.bar, 'whiskey', 2) // app.bar.whiskey is now reactive
        ```
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Component object structure

        ```
        {
          name: 'card', // used for debugging and recursion
          components: { CardHeader },
          template: '...',
          data() { return {...}; },
          props: {...},
          filters: {...}, // {{ timestamp | datetimeFilter }}
          computed: {...},
          methods: {...},
          mounted() {...} // or other lifecycle event
        }
        ```
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Props

        - Props allow data to be passed down to children
        - Mantra: props down, events up
        - Can bind them in to reactively pass changing data down or to retain data type
        - camelCase props become kebab-case attributes
        - Prop declaration can include "validation": type, required, default, validator
        - Avoid referencing parent components to maximize reuse

        ```
        props: ['userName', 'message'],
        ```

        ```
        props: {
          userName: String,
          timestamp: { type: [Number, String], required: true, default: Date.now() },
          message: { type: String, default() { return 'OMG I FORGOT A MESSAGE!!!' } }
        },
        ```
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Props

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="propsApp"&gt;&lt;/div&gt;

        &lt;script&gt;
          var stringRenderer = {
            name: 'string-renderer',
            props: { toRender: String },
            template: '<div>{{ toRender }}</div>'
          };

          var propsApp = new Vue({
            el: '#propsApp',
            data: { text: 'Finish presentation', },
            components: { stringRenderer },
            template: '<div><string-renderer :to-render="text">'
              + '</string-renderer></div>',
          });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="propsApp"></div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          var stringRenderer = {
            name: 'string-renderer',
            props: { toRender: String },
            template: '<div>{{ toRender }}</div>'
          };

          propsApp = new Vue({
            el: '#propsApp',
            data: { text: 'Finish presentation', },
            components: { stringRenderer },
            template: '<string-renderer :to-render="text"></string-renderer>',
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Styling

        ```
        <div class="always-class" :class="{ 'sometimes-class': sometimesToggle }">stuff</div>
        ```

        ```
        <div :style="{ width: someNumber }">more stuff</div>
        ```

        - Can even bind classes/styles on components, e.g.: `<card :class="{ red: isRed }"></card>`
          - Applied to root element of template
        - There is also an array based syntax for classes and styles
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Styling

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="classApp"&gt;&lt;/div&gt;

        &lt;script&gt;
          var stringRenderer = {
            props: { toRender: String },
            data() { return { isRed: false }; },
            template: '<div :class="{ red: isRed }">{{ toRender }}</div>',
            mounted() {
              var self = this;
              setInterval(function() { self.isRed = !self.isRed; }, 500);
            }
          };

          var classApp = new Vue({
            el: '#classApp',
            data: { text: 'This is green?' },
            components: { renderer: stringRenderer },
            template: '<renderer :to-render="text"></renderer>',
          });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="classApp"></div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          var stringRenderer = {
            props: { toRender: String },
            data() { return { isRed: false }; },
            template: '<div :class="{ red: isRed }">{{ toRender }}</div>',
            mounted() {
              var self = this;
              setInterval(function() { self.isRed = !self.isRed; }, 1000);
            }
          };

          classApp = new Vue({
            el: '#classApp',
            data: { text: 'This is green?' },
            components: { stringRenderer },
            template: '<string-renderer :to-render="text"></string-renderer>',
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Forms

        - Use `v-model` directive instead of `v-bind`
        - Shorthand for binding + event to pass changes back to component

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="formsApp"&gt;&lt;/div&gt;

        &lt;script&gt;
          var formsApp = new Vue({
            el: '#formsApp',
            data: { checked: false, message: '' },
            template: '<div><input type="checkbox" v-model="checked" />' +
            '<div>Checked: {{checked}}</div>' +
            '<input v-model="message" placeholder="message" />' +
            '<div>Message: {{message}}</div></div>',
          });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="formsApp"></div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          formsApp = new Vue({
            el: '#formsApp',
            data: { checked: false, message: '' },
            template: '<div><input type="checkbox" v-model="checked" />' +
            '<div>Checked: {{checked}}</div>' +
            '<input v-model="message" placeholder="message" />' +
            '<div>Message: {{message}}</div></div>',
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Conditionals

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="ifApp"&gt;&lt;/div&gt;

        &lt;script&gt;
          var ifApp = new Vue({
            el: '#ifApp',
            data: { checked: false, message: '' },
            template: '<div><input type="checkbox" v-model="checked" />' +
            '<div v-if="checked">Yes</div>' +
            '&lt;div v-else&gt;No&lt;/div&gt;' +
            '<div v-show="checked">Now you see me!</div></div>',
          });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="ifApp"></div>
        </div>
        </div>

        - There is also a `v-else-if` directive
        - `v-else-if` and `v-else` must be immediate sibling elements to the element with `v-if`
        - `v-if` vs `v-show`
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          ifApp = new Vue({
            el: '#ifApp',
            data: { checked: false, message: '' },
            template: '<div><input type="checkbox" v-model="checked" />' +
            '<div v-if="checked">Yes</div>' +
            '<div v-else>No</div>' +
            '<div v-show="checked">Now you see me!</div></div>',
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Lists

        - Render lists with `v-for` directive
        - Can put `v-for` on HTML elements, templates, or components
        - Source of list can be array, object, or range `v-for="x in 5"`
        - Get index with `v-for="(item, index) in items"`

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="listApp"&gt;&lt;/div&gt;

        &lt;script&gt;
          var listApp = new Vue({
            el: '#listApp',
            data: { items: [
              'Finish presentation',
              'Drink whiskey',
              'Play Zelda'] },
            template: '<div><ul>' +
            '<li v-for="item in items">{{item}}</li>' +
            '</ul></div>',
          });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="listApp"></div>
        </div>
        </div>

        <aside class="notes">
          - Must bind a key for components <br />
          - This does not pass data into components, still need bindings <br />
        </aside>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          listApp = new Vue({
            el: '#listApp',
            data: { items: [
              'Finish presentation',
              'Drink whiskey',
              'Play Zelda'] },
            template: '<div><ul>' +
            '<li v-for="item in items">{{item}}</li>' +
            '</ul></div>',
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Events and methods

        - 2 uses for events: interactivity and passing data up to parent components
        - Methods are bound to events with `v-on`, e.g.: `<button v-on:click="someMethod">Click me</button>`
        - `v-on` shorthand: `<button @click="otherMethod(username)">Submit</button>`
        - Component functions go in the `methods` property

        ```
        {
          methods: {
            someMethod() {...},
            otherMethod(username) {...}
          }
        }
        ```
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Events and methods

        <div class="clearfix">
          <div class="code-left">
        <pre><code>&lt;div id="eventApp"&gt;&lt;/div&gt;

        &lt;script&gt;
          var eventApp = new Vue({
            el: '#eventApp',
            template: '<div><button @click="popup()">Click me!</button>' +
            '<div v-show="showMessage">Get off my lawn!</div></div>',
            data() { return {showMessage: false}; },
            methods: {
              popup() {
               var self = this;
               self.showMessage = true;
               setTimeout(() => self.showMessage = false, 1000);
              }
            }
          });
        &lt;/script&gt;</code></pre>
          </div>

          <div class="output-right">
            <div id="eventApp"></div>
          </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          eventApp = new Vue({
            el: '#eventApp',
            template: '<div><button @click="popup()">Click me!</button>' +
            '<div v-show="showMessage">Get off my lawn!</div></div>',
            data() { return {showMessage: false}; },
            methods: {
              popup() {
                var self = this;
                self.showMessage = true;
                setTimeout(() => self.showMessage = false, 1000);
              }
            }
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Slots

        - What if you wanted a component that could act as a container for some other markup or component?
        - Angular called this "transclusion"
        - All template expressions are evaluated against the matching component instance

        <pre><code>&lt;template&gt;
          &lt;div class="card-stuff"&gt;
            &lt;slot name="header"&gt;&lt;/slot&gt;
            &lt;slot&gt;&lt;/slot&gt;
          &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
          export default {
            name: 'card',
          };
        &lt;/script&gt;</code></pre>

        <pre><code>&lt;card&gt;
            &lt;card-header slot="header"&gt;&lt;/card-header&gt;
            &lt;span&gt;{{ message }}&lt;/span&gt;
        &lt;/card&gt;</code></pre>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Advanced topics we missed

        - Refs
        - Watchers
        - Lifecycle Hooks
        - Filters
        - Custom directives
        - Transition effects
        - Render functions
        - Mixins
        - Plugins
        - Server side rendering
        - Unit testing
        - Deployment
        <aside class="notes">
          - Lifecycle Hooks: know about mounted, updated, destroyed <br />
          - Filters: use with bindings, takes in data and returns transformed value <br />
        </aside>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        # Vuex

        <blockquote class="fragment">
          Vuex is a state management pattern + library for Vue.js applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It also integrates with Vue's official devtools extension to provide advanced features such as zero-config time-travel debugging and state snapshot export / import. - [Vuex book](https://vuex.vuejs.org/en/intro.html)
        </blockquote>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Facebook's Flux

        <img src="flux.png" alt="Flux" style="height: 50vh"/>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Vuex

        <img src="vuex.png" alt="Vuex" style="height: 75vh"/>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Bootstrapping

        - `store` is injected into all components as `this.$store`
        - `store` does not get mangled like components do

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="vuexBootstrapApp"&gt;
          {{ $store.state.message }}
        &lt;/div&gt;

        &lt;script src="/path/to/vue.js"&gt;
        &lt;script src="/path/to/vuex.js"&gt;

        &lt;script&gt;
        var store = new Vuex.Store({
          state: {
            message: 'Hello Vue!'
          }
        });

        var vuexBootstrapApp = new Vue({
          el: '#vuexBootstrapApp',
          store // same as store: store
        });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="vuexBootstrapApp">
            {{ $store.state.message }}
          </div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          var store = new Vuex.Store({
            state: {
              message: 'Hello Vue!'
            }
          });

          vuexBootstrapApp = new Vue({
            el: '#vuexBootstrapApp',
            store // same as store: store
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## State

        - `state` is a tree that acts as the "single source of truth" for the state of your app
        - If your components were a single function and the return value was your page, `state` is the main parameter to that function
        - `state` is reactive
        - `mapState()` helps you turn state properties into computed component properties

        ```
        import { mapState } from 'vuex';
        export default {
          computed: {
            ...mapState({ // object syntax
              aMessage: state => state.message, // access with this.aMessage
              theMessage: 'message', // access with this.theMessage
            }),
            ...mapState(['message']) // array syntax; access with this.message
          }
        };
        ```
      </script>
    </section>
    <section data-markdown data-background-image="fightclub.gif">
      <script type="text/template">
        ## The first rule of Vuex:
        <h1 class="fragment">DON'T TRY TO CHANGE STATE FROM OUTSIDE OF THE STORE</h1>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Mutations

        - In order for Vuex to do its job, all mutations to `state` go through the store's `mutations`
        - Mutations are "committed": `store.commit('mutation name', valueToCommit)`
        - Object style commit: `store.commit({ type: 'mutation name', value: valueToCommit})`
        - There is a `mapMutations` helper to be used in a component's `methods` property
        - Mutations must be synchronous!
        - Best practice: use constants for your mutation names and store them together in a separate file
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Mutations

        <div class="clearfix">
        <div class="code-left">
        <pre><code>&lt;div id="vuexMutationApp"&gt;&lt;/div&gt;
        &lt;script&gt;
        var store = new Vuex.Store({
          state: { count: 0 },
          mutations: {
            increment(state, payload) { state.count += payload.amount; }
          }
        });

        var vuexMutationApp = new Vue({
          el: '#vuexMutationApp',
          template: '<div>{{count}}' +
          '<button @click="increment(1)">+1</button>' +
          '<button @click="increment(10)">+10</button></div>',
          methods: {
            increment(value) {
              this.$store.commit({type: 'increment', amount: value});
            }
          },
          store // same as store: store
        });
        &lt;/script&gt;</code></pre>
        </div>

        <div class="output-right">
          <div id="vuexMutationApp"></div>
        </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          var store = new Vuex.Store({
            state: { count: 0 },
            mutations: {
              increment(state, payload) { state.count += payload.amount; }
            }
          });

          vuexMutationApp = new Vue({
            el: '#vuexMutationApp',
            template: '<div>{{ this.$store.state.count }}' +
            '<button @click="increment(1)">+1</button>' +
            '<button @click="increment(10)">+10</button></div>',
            methods: {
              increment(value) {
                this.$store.commit({type: 'increment', amount: value});
              }
            },
            store
          });
        });
      </script>
    </section>
    <section data-markdown data-background-image="fightclub.gif">
      <script type="text/template">
        ## The second rule of Vuex:
        # DON'T CHANGE STATE FROM OUTSIDE OF THE STORE
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Actions

        - What if you need to commit multiple mutations together?
        - What if you need to do something async and commit the result?
        - Actions coordinate mutations and asynchronous operations
        - Actions are dispatched: `store.dispatch('action name', valueToDispatch)
        - Object style dispatch: `store.dispatch({ type: 'mutation name', value: valueToDispatch})`
        - Always return a Promise!

        ```
        var store = new Vuex.Store({
          ...,
          actions: {
            incrementAsync (context, payload) { // context is similar to state but not the same
              setTimeout(() => context.commit('increment'), 1000);
            }
          }
        };
        ```
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Vuex and external APIs

        <img src="vuex.png" alt="Vuex" style="height: 75vh"/>
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Forms and computed part deux

        - `v-model` mutates properties directly
        - What are the 1st and 2nd rules of Vuex?
        - Computed properties with getters and setters to the rescue!

        <div class="clearfix">
          <div class="code-left">
        <pre><code>&lt;div id="vuexFormsApp"&gt;&lt;/div&gt;

        &lt;script&gt;
        var store = new Vuex.Store({
          state: { message: 'Hello Vue!' },
          mutations: { setMessage(state, mess) { state.message = mess; } }
        });

        var vuexFormsApp = new Vue({
          el: '#vuexFormsApp',
          template: '<div><input v-model="message" placeholder="message" />' +
          '<div>Message: {{message}}</div></div>',
          computed: {
            message: {
             get: function() { return this.$store.state.message; },
             set: function(val) { this.$store.commit('setMessage', val); }
            }
          },
          store
        });
        &lt;/script&gt;</code></pre>
          </div>

          <div class="output-right">
            <div id="vuexFormsApp"></div>
          </div>
        </div>
      </script>
      <script>
        Reveal.addEventListener('ready', function() {
          var store = new Vuex.Store({
            state: { message: 'Hello Vue!' },
            mutations: { setMessage(state, message) { state.message = message; } }
          });
          vuexFormsApp = new Vue({
            el: '#vuexFormsApp',
            template: '<div><input v-model="message" placeholder="message" />' +
            '<div>Message: {{message}}</div></div>',
            computed: {
              message: {
                get: function() { return this.$store.state.message; },
                set: function(val) { this.$store.commit('setMessage', val); }
              }
            },
            store
          });
        });
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Application structure

        ```
        ├── index.html
        ├── main.js
        ├── api
        │   └── ... # abstractions for making API requests
        ├── components
        │   ├── App.vue
        │   ├── ComponentGroupA
        │   |   ├── ComponentA1
        │   |   └── ...
        │   ├── ComponentGroupB
        │   |   ├── ComponentB1
        │   |   └── ...
        │   └── ...
        └── store                 # can start with store.js for small apps
            ├── index.js          # where we assemble modules and export the store
            ├── actions.js        # root actions
            ├── mutations.js      # root mutations
            ├── mutationtypes.js  # mutation constants
            └── modules
                ├── cart.js       # cart module
                └── products.js   # products module
        ```
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Topics we missed

        - Getters
        - Modules
        - Strict Mode
        - Plugins
        - Hot Reloading
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        # Thanks for listening!
        ## Questions?
      </script>
    </section>
    <section data-markdown>
      <script type="text/template">
        ## Recommended resources

        - [Awesome Vue](https://github.com/vuejs/awesome-vue)
        - [Quasar](http://quasar-framework.org/)
        - [Vue.js Guide](https://vuejs.org/v2/guide/)
        - [Vuex book](https://vuex.vuejs.org/en/)
        - [vue-router book](https://router.vuejs.org/en/)
      </script>
    </section>
  </div>
</div>
<script>
  // More info https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    history: true,

    width: 1440,
    height: 900,
    margin: 0.1,

    // More info https://github.com/hakimel/reveal.js#dependencies
    dependencies: [
      { src: 'plugin/markdown/marked.js' },
      { src: 'plugin/markdown/markdown.js' },
      { src: 'plugin/notes/notes.js', async: true },
      {
        src: 'plugin/highlight/highlight.js',
        async: true,
        callback: function () {
          $('code').each(function(i, block) {
            hljs.highlightBlock(block);
          });
        }
      }
    ]
  });
</script>
<script>

</script>
</body>
</html>